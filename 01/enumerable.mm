<map version="0.9.0">
<!-- To view this file, download free mind mapping software FreeMind from http://freemind.sourceforge.net -->
<node text="enumerable.org" background_color="#00bfff">
<richcontent TYPE="NOTE"><html><head></head><body><p>--org-mode: WHOLE FILE</p></body></html></richcontent>
<node text="Enumerable" position="left">
<node style="bubble" background_color="#eeee00">
<richcontent TYPE="NODE"><html>
<head>
<style type="text/css">
<!--
p { margin-top: 3px; margin-bottom: 3px; }-->
</style>
</head>
<body>
<p><br />&#160;&#160;Si tenemos una clase que implementa el m&#xe9;todo each(&amp;block), al incluir<br />&#160;&#160;en ella el m&#xf3;dulo enumerable, &#xe9;ste nos brinda una serie de m&#xe9;todos que<br />&#160;&#160;lo utilizan para realizar distintas acciones sobre una colecci&#xf3;n.</p><p>&#160;&#160;A continuaci&#xf3;n una lista de dichos m&#xe9;todos:<br />&#160;&#160;</p></body>
</html>
</richcontent>
</node>
<node text="all?">
<node style="bubble" background_color="#eeee00">
<richcontent TYPE="NODE"><html>
<head>
<style type="text/css">
<!--
p { margin-top: 3px; margin-bottom: 3px; }-->
</style>
</head>
<body>
<p>Pasa cada uno de los elementos al bloque. El m&#xe9;todo devuelve<br />verdadero si el bloque nunca retorna false o nil y falso si alguno<br />el bloque devuelve false o nil en alguna de las iterciones.</p><p>El bloque es opcional y si no se provee, el m&#xe9;todo aporta un<br />bloque:</p><p>#+BEGIN_SRC ruby<br />[...].all? {|o| o}<br />#+END_SRC<br /></p></body>
</html>
</richcontent>
</node>
</node>
<node text="any?">
</node>
<node text="chunk">
</node>
<node text="collect, map">
</node>
<node text="collect_concat, flat_map">
</node>
<node text="count">
</node>
<node text="cycle">
</node>
<node text="detect, find">
</node>
<node text="drop">
</node>
<node text="drop_while">
</node>
<node text="each_cons">
</node>
<node text="each_entry">
</node>
<node text="each_slice">
</node>
<node text="each_with_index">
</node>
<node text="each_with_object">
</node>
<node text="entries, to_a">
</node>
<node text="find_all, select">
</node>
<node text="find_index">
</node>
<node text="first">
</node>
<node text="grep">
</node>
<node text="group_by">
</node>
<node text="include?, member?">
</node>
<node text="inject, reduce">
</node>
<node text="max">
</node>
<node text="max_by">
</node>
<node text="min">
</node>
<node text="min_by">
</node>
<node text="minmax">
</node>
<node text="minmax_by">
</node>
<node text="none?">
</node>
<node text="one?">
</node>
<node text="partition">
</node>
<node text="reject">
</node>
<node text="reverse_each">
</node>
<node text="slice_before">
</node>
<node text="sort">
</node>
<node text="sort_by">
</node>
<node text="take">
</node>
<node text="take_while">
</node>
<node text="zip">
<node style="bubble" background_color="#eeee00">
<richcontent TYPE="NODE"><html>
<head>
<style type="text/css">
<!--
p { margin-top: 3px; margin-bottom: 3px; }-->
</style>
</head>
<body>
<p></p><p></p></body>
</html>
</richcontent>
</node>
</node>
</node>
<node text="Actividad">
<node style="bubble" background_color="#eeee00">
<richcontent TYPE="NODE"><html>
<head>
<style type="text/css">
<!--
p { margin-top: 3px; margin-bottom: 3px; }-->
</style>
</head>
<body>
<p><br />&#160;&#160;Escribir un m&#xf3;dulo que utilice el m&#xe9;todo each para definir cada uno<br />&#160;&#160;de los m&#xe9;todos explicados anteriormente</p></body>
</html>
</richcontent>
</node>
</node>
</node>
</map>
